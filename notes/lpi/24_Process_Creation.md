# Chapter 24. Process Creation

## 24.1 Overview of fork(), exit(), wait(), and execve()

- Overview of four system calls:
    - The fork() system call allows one process, the parent, to create a new process, the child. This is done by making the new child process an (almost) exact duplicate of the parent: the child obtains copies of the parent’s stack, data, heap, and text segments (Section 6.3). The term fork derives from the fact that we can envisage the parent process as dividing to yield two copies of itself.
    - The exit(status) library function terminates a process, making all resources (memory, open file descriptors, and so on) used by the process available for subsequent reallocation by the kernel. The status argument is an integer that determines the termination status for the process. Using the wait() system call, the parent can retrieve this status.
    - The wait() system call allows a parent process to wait for its child processes to terminate and retrieve their exit status.
    - The execve() system call is used to replace the current process image with a new process image. This is commonly used to execute a new program within a process.
    - The execve(pathname, argv, envp) system call loads a new program (pathname, with argument list argv, and environment list envp) into a process’s memory. The existing program text is discarded, and the stack, data, and heap segments are freshly created for the new program. This operation is often referred to as execing a new program.
- Figure 24-1 provides an overview of how fork(), exit(), wait(), and execve() are commonly used together. (This diagram outlines the steps taken by the shell in executing a command: the shell continuously executes a loop that reads a command, performs various processing on it, and then forks a child process to exec the command.)
- The use of execve() shown in this diagram is optional. Sometimes, it is instead useful to have the child carry on executing the same program as the parent. In either case, the execution of the child is ultimately terminated by a call to exit() (or by delivery of a signal), yielding a termination status that the parent can obtain via wait().
- The call to wait() is likewise optional. The parent can simply ignore its child and continue executing. However, we’ll see later that the use of wait() is usually desirable, and is often employed within a handler for the SIGCHLD signal, which the kernel generates for a parent process when one of its children terminates. (By default, SIGCHLD is ignored, which is why we label it as being optionally delivered in the diagram.)

## 24.2 Creating a new process: fork()
- In many applications, creating multiple processes can be a useful way of dividing up a task. For example, a network server process may listen for incoming client requests and create a new child process to handle each request; meanwhile, the server process continues to listen for further client connections. Dividing tasks up in this way often makes application design simpler. It also permits greater concurrency (i.e., more tasks or requests can be handled simultaneously).
- The fork() system call creates a new process, the child, which is an almost exact duplicate of the calling process, the parent.
- The key point to understanding fork() is to realize that after it has completed its work, two processes exist, and, in each process, execution continues from the point where fork() returns. The two processes are executing the same program text, but they have separate copies of the stack, data, and heap segments. The child’s stack, data, and heap segments are initially exact duplicates of the corresponding parts the parent’s memory. After the fork(), each process can modify the variables in its stack, data, and heap segments without affecting the other process.
- Within the code of a program, we can distinguish the two processes via the value returned from fork(). For the parent, fork() returns the process ID of the newly created child. This is useful because the parent may create, and thus need to track, several children (via wait() or one of its relatives). For the child, fork() returns 0.

### 24.2.2 Memory Semantics of fork()

- Conceptually, we can consider fork() as creating copies of the parent’s text, data, heap, and stack segments.

> However, actually performing a simple copy of the parent’s virtual memory pages into the new child process would be wasteful for a number of reasons—one being that a fork() is often followed by an exec(), which replaces the process’s text with a new program and reinitializes the process’s data, heap, and stack segments.

Most modern UNIX implementations, including Linux, use two techniques to avoid such wasteful copying:
- The kernel marks the text segment of each process as read-only, so that a process can’t modify its own code. This means that the parent and child can share the same text segment. The fork() system call creates a text segment for the child by building a set of per-process page-table entries that refer to the same virtual memory page frames already used by the parent.
- For the pages in the data, heap, and stack segments of the parent process, the kernel employs a technique known as copy-on-write. This means that the parent and child processes initially share the same physical memory pages for these segments. However, if either process attempts to modify a shared page, the kernel makes a copy of the page for the modifying process, ensuring that the changes do not affect the other process. Initially,
the kernel sets things up so that the page-table entries for these segments refer to the same physical memory pages as the corresponding page-table entries in the parent, and the pages themselves are marked read-only. After the fork(), the kernel traps any attempts by either the parent or the child to modify one of these pages, and makes a duplicate copy of the about-to-be-modified page. This new page copy is assigned to the faulting process, and the corresponding pagetable entry for the child is adjusted appropriately. From this point on, the parent
and child can each modify their private copies of the page, without the changes being visible to the other process. Figure 24-2 illustrates the copy-on-write technique.

## 24.6 Summary
- The fork() system call creates a new process (the child) by making an almost exact duplicate of the calling process (the parent).
- After a fork() call, we can’t rely on the order in which the parent and the child are next scheduled to use the CPU(s). Programs that make assumptions about the order of execution are susceptible to errors known as race conditions. Because the occurrence of such errors depends on external factors such as system load, they can be difficult to find and debug.